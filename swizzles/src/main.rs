use std::fs::File;
use std::io::Write;

fn write_swizzle_head(out: &mut impl Write) -> std::io::Result<()> {
    write!(
        out,
        r#"// Generated by swizzles. Do not edit.
use super::{{Vec2, Vec3, Vec3A, Vec4}};

#[cfg(all(vec4_sse2, target_arch = "x86"))]
use core::arch::x86::*;
#[cfg(all(vec4_sse2, target_arch = "x86_64"))]
use core::arch::x86_64::*;
"#
    )
}

fn write_swizzle_vec4(out: &mut impl Write) -> std::io::Result<()> {
    const SIZE: usize = 4;
    const E: [char; SIZE] = ['x', 'y', 'z', 'w']; // element name
    const B: [&str; SIZE] = ["00", "01", "10", "11"]; // shuffle bits

    write!(out, "\nimpl Vec4 {{")?;

    // to vec4
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                for e3 in 0..SIZE {
                    if e0 == 0 && e1 == 1 && e2 == 2 && e3 == 3 {
                        continue;
                    }

                    write!(
                        out,
                        r#"
    #[inline]
    pub fn {}{}{}{}(self) -> Vec4 {{
        #[cfg(vec4_sse2)]
        unsafe {{
            Vec4(_mm_shuffle_ps(self.0, self.0, 0b{}_{}_{}_{}))
        }}

        #[cfg(vec4_f32)]
        {{
            Vec4(self.{}, self.{}, self.{}, self.{})
        }}
    }}"#,
                        E[e0], E[e1], E[e2], E[e3], B[e3], B[e2], B[e1], B[e0], e0, e1, e2, e3,
                    )?;
                }
            }
        }
    }

    // to vec3
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                write!(
                    out,
                    r#"
    #[inline]
    pub fn {}{}{}(self) -> Vec3 {{
        #[cfg(vec4_sse2)]
        unsafe {{
            Vec3::from(Vec4(_mm_shuffle_ps(self.0, self.0, 0b00_{}_{}_{})))
        }}

        #[cfg(vec4_f32)]
        {{
            Vec3(self.{}, self.{}, self.{})
        }}
    }}"#,
                    E[e0], E[e1], E[e2], B[e2], B[e1], B[e0], e0, e1, e2
                )?;
            }
        }
    }

    // to vec2
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            write!(
                out,
                r#"
    #[inline]
    pub fn {}{}(self) -> Vec2 {{
        #[cfg(vec4_sse2)]
        unsafe {{
            Vec2::from(Vec4(_mm_shuffle_ps(self.0, self.0, 0b00_00_{}_{})))
        }}

        #[cfg(vec4_f32)]
        {{
            Vec2(self.{}, self.{})
        }}
    }}"#,
                E[e0], E[e1], B[e1], B[e0], e0, e1
            )?;
        }
    }

    write!(out, "\n}}\n")?;

    Ok(())
}

fn write_swizzle_vec3a(out: &mut impl Write) -> std::io::Result<()> {
    const SIZE: usize = 3;
    const E: [char; SIZE] = ['x', 'y', 'z']; // element name
    const B: [&str; SIZE] = ["00", "01", "10"]; // shuffle bits

    write!(out, "\nimpl Vec3A {{")?;

    // to vec4
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                for e3 in 0..SIZE {
                    write!(
                        out,
                        r#"
    #[inline]
    pub fn {}{}{}{}(self) -> Vec4 {{
        #[cfg(vec3a_sse2)]
        unsafe {{
            Vec4(_mm_shuffle_ps(self.0, self.0, 0b{}_{}_{}_{}))
        }}

        #[cfg(vec3a_f32)]
        {{
            Vec4(self.0.{}, self.0.{}, self.0.{}, self.0.{})
        }}
    }}"#,
                        E[e0], E[e1], E[e2], E[e3], B[e3], B[e2], B[e1], B[e0], e0, e1, e2, e3,
                    )?;
                }
            }
        }
    }

    // to vec3
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                if e0 == 0 && e1 == 1 && e2 == 2 {
                    continue;
                }
                write!(
                    out,
                    r#"
    #[inline]
    pub fn {}{}{}(self) -> Vec3A {{
        #[cfg(vec3a_sse2)]
        unsafe {{
            Vec3A(_mm_shuffle_ps(self.0, self.0, 0b00_{}_{}_{}))
        }}

        #[cfg(vec3a_f32)]
        {{
            Vec3A(Vec3(self.0.{}, self.0.{}, self.0.{}))
        }}
    }}"#,
                    E[e0], E[e1], E[e2], B[e2], B[e1], B[e0], e0, e1, e2
                )?;
            }
        }
    }

    // to vec2
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            write!(
                out,
                r#"
    #[inline]
    pub fn {}{}(self) -> Vec2 {{
        #[cfg(vec3a_sse2)]
        unsafe {{
            Vec2::from(Vec3A(_mm_shuffle_ps(self.0, self.0, 0b00_00_{}_{})))
        }}

        #[cfg(vec3a_f32)]
        {{
            Vec2(self.0.{}, self.0.{})
        }}
    }}"#,
                E[e0], E[e1], B[e1], B[e0], e0, e1
            )?;
        }
    }

    write!(out, "\n}}\n")?;

    Ok(())
}

fn write_swizzle_vec3(out: &mut impl Write) -> std::io::Result<()> {
    const SIZE: usize = 3;
    const E: [char; SIZE] = ['x', 'y', 'z']; // element name

    write!(out, "\nimpl Vec3 {{")?;

    // to vec4
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                for e3 in 0..SIZE {
                    write!(
                        out,
                        r#"
    #[inline]
    pub fn {}{}{}{}(self) -> Vec4 {{
        Vec4::new(self.{}, self.{}, self.{}, self.{})
    }}"#,
                        E[e0], E[e1], E[e2], E[e3], e0, e1, e2, e3,
                    )?;
                }
            }
        }
    }

    // to vec3
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                if e0 == 0 && e1 == 1 && e2 == 2 {
                    continue;
                }
                write!(
                    out,
                    r#"
    #[inline]
    pub fn {}{}{}(self) -> Vec3 {{
        Vec3(self.{}, self.{}, self.{})
    }}"#,
                    E[e0], E[e1], E[e2], e0, e1, e2
                )?;
            }
        }
    }

    // to vec2
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            write!(
                out,
                r#"
    #[inline]
    pub fn {}{}(self) -> Vec2 {{
        Vec2(self.{}, self.{})
    }}"#,
                E[e0], E[e1], e0, e1
            )?;
        }
    }

    write!(out, "\n}}\n")?;

    Ok(())
}

fn write_swizzle_vec2(out: &mut impl Write) -> std::io::Result<()> {
    const SIZE: usize = 2;
    const E: [char; SIZE] = ['x', 'y']; // element name

    write!(out, "\nimpl Vec2 {{")?;

    // to vec4
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                for e3 in 0..SIZE {
                    write!(
                        out,
                        r#"
    #[inline]
    pub fn {}{}{}{}(self) -> Vec4 {{
        Vec4::new(self.{}, self.{}, self.{}, self.{})
    }}"#,
                        E[e0], E[e1], E[e2], E[e3], e0, e1, e2, e3,
                    )?;
                }
            }
        }
    }

    // to vec3
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                write!(
                    out,
                    r#"
    #[inline]
    pub fn {}{}{}(self) -> Vec3 {{
        Vec3(self.{}, self.{}, self.{})
    }}"#,
                    E[e0], E[e1], E[e2], e0, e1, e2
                )?;
            }
        }
    }

    // to vec2
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            if e0 == 0 && e1 == 1 {
                continue;
            }
            write!(
                out,
                r#"
    #[inline]
    pub fn {}{}(self) -> Vec2 {{
        Vec2(self.{}, self.{})
    }}"#,
                E[e0], E[e1], e0, e1
            )?;
        }
    }

    write!(out, "\n}}\n")?;

    Ok(())
}

fn write_src() -> std::io::Result<()> {
    let mut out = File::create("../src/f32/swizzle.rs")?;
    write_swizzle_head(&mut out)?;
    write_swizzle_vec4(&mut out)?;
    write_swizzle_vec3a(&mut out)?;
    write_swizzle_vec3(&mut out)?;
    write_swizzle_vec2(&mut out)?;
    Ok(())
}

fn write_test_head(out: &mut impl Write) -> std::io::Result<()> {
    write!(
        out,
        r#"// Generated by swizzles. Do not edit.
use glam::{{Vec2, Vec3, Vec3A, Vec4}};
"#
    )?;
    Ok(())
}

fn write_test_vec4(out: &mut impl Write) -> std::io::Result<()> {
    const SIZE: usize = 4;
    const E: [char; SIZE] = ['x', 'y', 'z', 'w']; // element name
    const V: [&str; SIZE] = ["1.0", "2.0", "3.0", "4.0"]; //element value

    write!(
        out,
        r#"
#[test]
fn test_vec4_swizzles() {{
    let v = Vec4::new(1.0, 2.0, 3.0, 4.0);
"#
    )?;

    // to vec4
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                for e3 in 0..SIZE {
                    if e0 == 0 && e1 == 1 && e2 == 2 && e3 == 3 {
                        continue;
                    }
                    writeln!(
                        out,
                        "    assert_eq!(v.{}{}{}{}(), Vec4::new({}, {}, {}, {}));",
                        E[e0], E[e1], E[e2], E[e3], V[e0], V[e1], V[e2], V[e3]
                    )?;
                }
            }
        }
    }

    // to vec3
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                writeln!(
                    out,
                    "    assert_eq!(v.{}{}{}(), Vec3::new({}, {}, {}));",
                    E[e0], E[e1], E[e2], V[e0], V[e1], V[e2]
                )?;
            }
        }
    }

    // to vec2
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            writeln!(
                out,
                "    assert_eq!(v.{}{}(), Vec2::new({}, {}));",
                E[e0], E[e1], V[e0], V[e1]
            )?;
        }
    }

    writeln!(out, "}}")?;

    Ok(())
}

fn write_test_vec3a(out: &mut impl Write) -> std::io::Result<()> {
    const SIZE: usize = 3;
    const E: [char; SIZE] = ['x', 'y', 'z']; // element name
    const V: [&str; SIZE] = ["1.0", "2.0", "3.0"]; //element value

    write!(
        out,
        r#"
#[test]
fn test_vec3a_swizzles() {{
    let v = Vec3A::new(1.0, 2.0, 3.0);
"#
    )?;

    // to vec4
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                for e3 in 0..SIZE {
                    writeln!(
                        out,
                        "    assert_eq!(v.{}{}{}{}(), Vec4::new({}, {}, {}, {}));",
                        E[e0], E[e1], E[e2], E[e3], V[e0], V[e1], V[e2], V[e3]
                    )?;
                }
            }
        }
    }

    // to vec3
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            for e2 in 0..SIZE {
                if e0 == 0 && e1 == 1 && e2 == 2 {
                    continue;
                }
                writeln!(
                    out,
                    "    assert_eq!(v.{}{}{}(), Vec3A::new({}, {}, {}));",
                    E[e0], E[e1], E[e2], V[e0], V[e1], V[e2]
                )?;
            }
        }
    }

    // to vec2
    for e0 in 0..SIZE {
        for e1 in 0..SIZE {
            writeln!(
                out,
                "    assert_eq!(v.{}{}(), Vec2::new({}, {}));",
                E[e0], E[e1], V[e0], V[e1]
            )?;
        }
    }

    writeln!(out, "}}")?;

    Ok(())
}

fn write_test() -> std::io::Result<()> {
    let mut out = File::create("../tests/swizzle.rs")?;
    write_test_head(&mut out)?;
    write_test_vec4(&mut out)?;
    write_test_vec3a(&mut out)?;
    Ok(())
}

fn main() -> std::io::Result<()> {
    write_src()?;
    write_test()?;
    Ok(())
}
